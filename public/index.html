<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keith's Jian Weather Tower</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- 引入 Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            /* 針對參考圖片高度還原深灰質感 */
            --bg-color: #1A1A1C;
            --card-bg: #2C2C2E;
            --text-main: #FFFFFF;
            --text-sub: #A1A1AA;
            --border-color: #3A3A3C;
            --chart-red: #EF4444;
            --chart-green: #22C55E;
            --chart-blue: #3B82F6;
            --chart-orange: #F97316;
            --chart-cyan: #06B6D4;
        }

        * {
            box-sizing: border-box;
            font-family: 'Roboto', sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        #app-container {
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
        }

        #main-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 10px;
        }

        #update-time-text {
            color: var(--text-sub);
            font-size: 14px;
            font-weight: 500;
        }

        #toggle-view-btn {
            background-color: var(--bg-color);
            color: var(--text-main);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        #toggle-view-btn:hover {
            background-color: var(--card-bg);
            border-color: #555;
        }

        .dashboard {
            /* 頂級版本採用更長方形的 6 張獨立卡片，支援動態換行 */
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            width: 100%;
        }

        /* 歷史時序圖容器 */
        #history-view {
            display: none;
            flex-direction: column;
            gap: 16px;
            width: 100%;
        }

        #history-summary {
            display: flex;
            justify-content: space-around;
            background-color: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            padding: 16px;
            margin-bottom: 8px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .summary-item {
            text-align: center;
        }

        .summary-label {
            font-size: 14px;
            color: var(--text-main);
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .summary-val {
            font-size: 18px;
            color: var(--text-main);
            font-weight: 500;
        }

        .summary-unit {
            font-size: 11px;
            color: var(--text-sub);
        }

        .history-card {
            background-color: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            padding: 16px;
            width: 100%;
            height: 250px;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 20px;
            /* 圓潤外框 */
            border: 1px solid var(--border-color);
            /* 仿製 Apple 的 1px 光澤感 */
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .card-title {
            font-size: 18px;
            color: var(--text-main);
            letter-spacing: 2px;
            font-weight: 700;
            margin-bottom: 20px;
            width: 100%;
            text-align: center;
        }

        .widget-container {
            width: 140px;
            height: 140px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .value-box {
            margin-top: auto;
            width: 100%;
        }

        .main-value {
            font-size: 42px;
            font-weight: 400;
            line-height: 1;
        }

        .unit {
            font-size: 18px;
            color: var(--text-sub);
            margin-left: 2px;
            vertical-align: super;
        }

        .sub-value {
            font-size: 12px;
            color: #8E8E93;
            text-transform: uppercase;
            font-weight: 500;
            margin-top: 10px;
            letter-spacing: 0.5px;
        }

        .sub-value-2 {
            font-size: 12px;
            color: #8E8E93;
            text-transform: uppercase;
            margin-top: 4px;
        }

        /* 手機版與平板版自適應 RWD */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .dashboard {
                grid-template-columns: 1fr;
            }

            .widget-container {
                width: 120px;
                height: 120px;
            }

            .main-value {
                font-size: 36px;
            }
        }
    </style>
</head>

<body>
    <div id="app-container">
        <!-- 頂端控制列 -->
        <div id="main-header">
            <div id="update-time-text">等待資料載入中...</div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <input type="date" id="history-date-picker"
                    style="display: none; background: var(--bg-color); color: var(--text-main); border: 1px solid var(--border-color); padding: 7px 12px; border-radius: 8px; color-scheme: dark; font-size: 13px; font-weight: 500; cursor: pointer;"
                    onchange="onDateChange()">
                <button id="toggle-view-btn" onclick="toggleView()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 3v18h18" />
                        <path d="m19 9-5 5-4-4-3 3" />
                    </svg>
                    切換時序圖
                </button>
            </div>
        </div>

        <!-- 儀表板視角 -->
        <div class="dashboard" id="dashboard">
            <!-- Dashboard populated by JS -->
        </div>

        <!-- 歷史時序圖視角 -->
        <div id="history-view">
            <div id="history-summary">
                <!-- 由 JS 動態填入當日極值 -->
            </div>
            <div class="history-card">
                <canvas id="chart-temp-dewpt"></canvas>
            </div>
            <div class="history-card">
                <canvas id="chart-humidity"></canvas>
            </div>
            <div class="history-card">
                <canvas id="chart-wind-speed"></canvas>
            </div>
            <div class="history-card" style="height: 200px;">
                <canvas id="chart-wind-dir"></canvas>
            </div>
            <div class="history-card" style="height: 200px;">
                <canvas id="chart-precip"></canvas>
            </div>
            <div class="history-card">
                <canvas id="chart-pressure"></canvas>
            </div>
        </div>
    </div>

    <script>
        const API_URL = '/api/weather/latest';

        function getWindDirection(degree) {
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.floor((degree + 11.25) / 22.5) % 16;
            return directions[index];
        }

        /* 1. 溫度: 漸層彩色圓弧儀表板 (SVG 內建多段路徑實作) */
        function buildSVGTempGauge(temp) {
            const minT = -10; const maxT = 40;
            let percent = (temp - minT) / (maxT - minT);
            if (percent < 0) percent = 0; if (percent > 1) percent = 1;
            const angle = -135 + (percent * 270);

            // 為了讓漸層完美順著圓弧，且不在各個瀏覽器上破圖
            // 最穩定的做法是將圓弧拆成兩半：左半邊(冷色系) & 右半邊(暖色系)
            // 並各自使用直向/橫向的線性漸層來黏合，視覺上就會像是順著圓弧變色
            return `
            <svg viewBox="0 0 100 100" style="width:100%; height:100%; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.6));">
                <defs>
                    <!-- 左半邊：由下(深藍) 到 上(亮綠) -->
                    <linearGradient id="coolGrad" x1="0%" y1="100%" x2="0%" y2="0%">
                        <stop offset="0%" stop-color="#145A6E" />  <!-- 深青/藍 -->
                        <stop offset="20%" stop-color="#8CD0E3" /> <!-- 淺藍 -->
                        <stop offset="60%" stop-color="#1A8A4D" /> <!-- 深綠 -->
                        <stop offset="100%" stop-color="#84C665" /> <!-- 亮綠 -->
                    </linearGradient>
                    <!-- 右半邊：由上(橘黃) 到 下(紫紅) -->
                    <linearGradient id="warmGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="#FCE182" />   <!-- 鵝黃 -->
                        <stop offset="30%" stop-color="#F28E19" />  <!-- 橘色 -->
                        <stop offset="60%" stop-color="#DE1A2C" />  <!-- 紅色 -->
                        <stop offset="100%" stop-color="#702282" /> <!-- 紫色 -->
                    </linearGradient>
                </defs>
                
                <!-- 底部暗黑背景圓弧 -->
                <path d="M 22 75 A 38 38 0 1 1 78 75" fill="none" stroke="#222" stroke-width="16" stroke-linecap="round" />
                
                <!-- 左半邊溫度軌道 (使用 stroke-dasharray 切割一半) -->
                <!-- 圓半徑 r=38, 圓周長為 238.76, 1/2 圓弧長度大概是 119 -->
                <path d="M 22 75 A 38 38 0 0 1 50 12" fill="none" stroke="url(#coolGrad)" stroke-width="16" stroke-linecap="round" />
                
                <!-- 右半邊溫度軌道 -->
                <path d="M 50 12 A 38 38 0 0 1 78 75" fill="none" stroke="url(#warmGrad)" stroke-width="16" stroke-linecap="round" />
                
                <!-- 白色指針 -->
                <g transform="translate(50, 50) rotate(${angle})">
                    <line x1="0" y1="0" x2="0" y2="-28" stroke="#FFF" stroke-width="4.5" stroke-linecap="round"/>
                    <circle cx="0" cy="0" r="7" fill="#FFF"/>
                </g>
            </svg>
            `;
        }

        /* 2. 露點: 藍色漸層水滴 */
        function buildSVGDewPoint() {
            return `
            <svg viewBox="0 0 100 100" style="width:100%; height:100%; filter: drop-shadow(0 0 8px rgba(0,0,0,0.5));">
                <defs>
                    <linearGradient id="dropGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="#38BDF8" />
                        <stop offset="100%" stop-color="#0284C7" />
                    </linearGradient>
                </defs>
                <path d="M50 15 C 50 15, 20 50, 20 70 A 30 30 0 0 0 80 70 C 80 50, 50 15, 50 15 Z" fill="url(#dropGradient)" />
                <circle cx="50" cy="70" r="14" fill="#7DD3FC" opacity="0.4"/>
            </svg>
            `;
        }

        /* 3. 濕度: 雷達掃描圓餅 */
        function buildSVGHumidity(hum) {
            const radius = 38;
            const circum = 2 * Math.PI * radius;
            const dash = (hum / 100) * circum;
            return `
            <svg viewBox="0 0 100 100" style="width:100%; height:100%; transform: rotate(-90deg); filter: drop-shadow(0 0 8px rgba(0,0,0,0.5));">
                <!-- 底部暗灰圈 -->
                <circle cx="50" cy="50" r="${radius}" fill="#455A64" opacity="0.3" />
                <!-- 藍色環形 (依據濕度填滿) -->
                <circle cx="50" cy="50" r="${radius}" fill="none" stroke="#0EA5E9" stroke-width="24" stroke-dasharray="${dash} ${circum}" opacity="0.85" />
                <!-- 內部深色圓 -->
                <circle cx="50" cy="50" r="26" fill="var(--card-bg)" />
            </svg>
            `;
        }

        /* 4. 風向風速: 具羅盤刻度的動態圓盤 */
        function buildSVGWind(dir) {
            let ticks = '';
            for (let i = 0; i < 360; i += 5) {
                const isMajor = i % 90 === 0;
                const len = isMajor ? 5 : 2;
                ticks += `<line x1="50" y1="8" x2="50" y2="${8 + len}" stroke="${isMajor ? '#FFF' : '#666'}" stroke-width="${isMajor ? 2 : 1}" transform="rotate(${i} 50 50)" />`;
            }
            return `
            <svg viewBox="0 0 100 100" style="width:100%; height:100%;">
                ${ticks}
                <!-- 羅盤文字 -->
                <text x="50" y="24" fill="#FFF" font-size="9" font-weight="bold" text-anchor="middle">N</text>
                <text x="50" y="83" fill="#FFF" font-size="9" font-weight="bold" text-anchor="middle">S</text>
                <text x="22" y="53" fill="#FFF" font-size="9" font-weight="bold" text-anchor="middle">W</text>
                <text x="78" y="53" fill="#FFF" font-size="9" font-weight="bold" text-anchor="middle">E</text>
                
                <!-- 動態風向箭頭 -->
                <g transform="translate(50,50) rotate(${dir})">
                    <polygon points="-5,-30 5,-30 0,-42" fill="#FFF" />
                </g>
            </svg>
            `;
        }

        /* 5. 降雨: 立體網狀量筒 */
        function buildSVGPrecip(precip) {
            // 抓取最大裝水量，假設 50mm 為滿
            let percent = precip / 50; if (percent > 1) percent = 1;
            const h = 50 * percent;
            return `
            <svg viewBox="0 0 100 100" style="width:100%; height:100%; filter: drop-shadow(0 0 5px rgba(0,0,0,0.3));">
                <!-- 圓柱頂部開口 -->
                <ellipse cx="50" cy="25" rx="20" ry="6" fill="none" stroke="#666" stroke-width="2"/>
                <!-- 圓柱邊緣與底座 -->
                <path d="M 30 25 L 30 75 A 20 6 0 0 0 70 75 L 70 25" fill="none" stroke="#666" stroke-width="2"/>
                
                <!-- 若有降水則以藍色填充高度 -->
                ${h > 0 ? `<path d="M 30 ${75 - h} L 30 75 A 20 6 0 0 0 70 75 L 70 ${75 - h} A 20 6 0 0 1 30 ${75 - h}" fill="#38BDF8" opacity="0.6"/>` : ''}
            </svg>
            `;
        }

        /* 6. 氣壓: 小時鐘般的指針類比刻度 */
        function buildSVGPressure(press) {
            // 將 950 ~ 1050 的氣壓範圍映射到羅盤的 270 度
            const minP = 950; const maxP = 1050;
            let percent = (press - minP) / (maxP - minP);
            if (percent < 0) percent = 0; if (percent > 1) percent = 1;
            const angle = -135 + (percent * 270);

            let ticks = '';
            for (let i = 0; i <= 100; i += 2) {
                const a = -135 + (i * 2.7);
                const isMajor = i % 10 === 0;
                const len = isMajor ? 6 : 3;
                ticks += `<line x1="50" y1="12" x2="50" y2="${12 + len}" stroke="${isMajor ? '#CCC' : '#666'}" stroke-width="${isMajor ? 2 : 1}" transform="rotate(${a} 50 50)" />`;
            }

            return `
            <svg viewBox="0 0 100 100" style="width:100%; height:100%;">
                <!-- 氣壓計邊框 -->
                <circle cx="50" cy="50" r="42" fill="#3A3A3C" stroke="#222" stroke-width="2"/>
                <!-- 白色圓盤 -->
                <circle cx="50" cy="50" r="38" fill="#F4F4F5"/>
                ${ticks}
                
                <!-- 羅盤數字 -->
                <g fill="#111" font-size="5" text-anchor="middle" font-weight="bold">
                    <text x="50" y="27" transform="rotate(-90 50 50)">950</text>
                    <text x="50" y="27" transform="rotate(-40 50 50)">982</text>
                    <text x="50" y="27" transform="rotate(10 50 50)">1013</text>
                    <text x="50" y="27" transform="rotate(60 50 50)">1040</text>
                </g>

                <!-- 紅色指針 -->
                <g transform="translate(50, 50) rotate(${angle})">
                    <line x1="0" y1="0" x2="0" y2="-28" stroke="#EF4444" stroke-width="2.5" stroke-linecap="round"/>
                    <circle cx="0" cy="0" r="4.5" fill="#EF4444"/>
                    <circle cx="0" cy="-20" r="2" fill="#FFF"/> <!-- 紅色指針上的白光澤點 -->
                </g>
                <circle cx="50" cy="50" r="1.5" fill="#000"/>
            </svg>
            `;
        }

        async function fetchWeatherData() {
            try {
                const response = await fetch(API_URL);
                const data = await response.json();
                const obs = data.observations[0];
                const metric = obs.metric;

                // 風向風速處理
                const reversedWindDir = (obs.winddir + 180) % 360;
                const windSpeedKmh = metric.windSpeed;
                const windGustKmh = metric.windGust;
                // 注意：參考圖片風速使用的是 kph (km/h)，因使用者先前要求 m/s，這裡我們維持 m/s
                const windSpeedMsNum = metric.windSpeed / 3.6;
                const windGustMsNum = metric.windGust / 3.6;

                const dashboard = document.getElementById('dashboard');

                // 生產 HTML (6卡片)
                dashboard.innerHTML = `
                    <div class="card">
                        <div class="card-title">目前溫度</div>
                        <div class="widget-container">
                            ${buildSVGTempGauge(metric.temp)}
                        </div>
                        <div class="value-box">
                            <span class="main-value">${metric.temp}</span><span class="unit">°C</span>
                            <div class="sub-value">TEMPERATURE</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-title">露點溫度</div>
                        <div class="widget-container">
                            ${buildSVGDewPoint()}
                        </div>
                        <div class="value-box">
                            <span class="main-value">${metric.dewpt}</span><span class="unit">°C</span>
                            <div class="sub-value">DEW POINT</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-title">相對濕度</div>
                        <div class="widget-container">
                            ${buildSVGHumidity(obs.humidity)}
                        </div>
                        <div class="value-box">
                            <span class="main-value">${obs.humidity}</span><span class="unit">%</span>
                            <div class="sub-value">HUMIDITY</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-title">風向風速</div>
                        <div class="widget-container">
                            ${buildSVGWind(reversedWindDir)}
                        </div>
                        <div class="value-box">
                            <span class="main-value">${windSpeedMsNum.toFixed(1)}</span><span class="unit">m/s</span>
                            <div class="sub-value">Gusts ${windGustMsNum.toFixed(1)} m/s</div>
                            <div class="sub-value-2">${reversedWindDir}° ${getWindDirection(reversedWindDir)}</div>
                            <div class="sub-value-2" style="margin-top: 8px;">WIND</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-title">日降雨量</div>
                        <div class="widget-container">
                            ${buildSVGPrecip(metric.precipTotal)}
                        </div>
                        <div class="value-box">
                            <span class="main-value">${metric.precipTotal.toFixed(1)}</span><span class="unit">mm</span>
                            <div class="sub-value">${metric.precipRate.toFixed(1)} MM/HR</div>
                            <div class="sub-value-2">PRECIPITATION</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-title">大氣壓力</div>
                        <div class="widget-container">
                            ${buildSVGPressure(metric.pressure)}
                        </div>
                        <div class="value-box">
                            <span class="main-value">${Math.round(metric.pressure)}</span><span class="unit">hPa</span>
                            <div class="sub-value">PRESSURE</div>
                        </div>
                    </div>
                `;
                document.getElementById('update-time-text').innerText = `資料時間: ${new Date().toLocaleTimeString()}`;

            } catch (error) {
                console.error('獲取天氣數據失敗:', error);
                document.getElementById('dashboard').innerHTML = '<div style="color:white;text-align:center;width:100%;grid-column: 1/-1;">無法載入資料，請確認後端伺服器已啟動。</div>';
            }
        }

        fetchWeatherData();
        setInterval(fetchWeatherData, 60000);

        // ----------------------------------------------------
        // 時序圖相關邏輯
        // ----------------------------------------------------
        let isHistoryView = false;

        // 初始化日期選擇器為今天
        const datePicker = document.getElementById('history-date-picker');
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        datePicker.value = `${yyyy}-${mm}-${dd}`;

        // 當使用者改變日期時重新畫圖
        function onDateChange() {
            fetchHistoryData(datePicker.value);
        }

        // 切換視圖
        function toggleView() {
            const dashboard = document.getElementById('dashboard');
            const historyView = document.getElementById('history-view');
            const toggleBtn = document.getElementById('toggle-view-btn');

            isHistoryView = !isHistoryView;

            if (isHistoryView) {
                dashboard.style.display = 'none';
                historyView.style.display = 'flex';
                datePicker.style.display = 'block'; // 顯示日期選擇器
                toggleBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg> 返回儀表板';

                // 打開切換時，自動根據當前選擇日期抓取資料
                fetchHistoryData(datePicker.value);
            } else {
                dashboard.style.display = 'grid';
                historyView.style.display = 'none';
                datePicker.style.display = 'none'; // 隱藏日期選擇器
                toggleBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="m19 9-5 5-4-4-3 3"/></svg> 切換時序圖';
            }
        }

        // 抓取指定日期，或是最後 24 小時資料
        async function fetchHistoryData(dateStr) {
            try {
                // 如果有給日期就加上 Query 參數
                const url = dateStr ? `/api/weather/history?date=${dateStr}` : '/api/weather/history';
                const response = await fetch(url);
                const data = await response.json();

                if (data && data.length > 0) {
                    renderCharts(data);
                } else {
                    alert(`選取的日期 (${dateStr}) 沒有觀測紀錄。`);
                    // Optionally clear charts here if you wish, for now we leave the old view
                }
            } catch (error) {
                console.error('取得時序圖資料失敗:', error);
            }
        }

        // 共用 Chart.js 全局設定
        Chart.defaults.color = '#E4E4E7'; // 提亮文字顏色
        Chart.defaults.font.family = "'Roboto', sans-serif";
        Chart.defaults.font.size = 14;    // 設定預設字體大小
        Chart.defaults.plugins.tooltip.mode = 'index';
        Chart.defaults.plugins.tooltip.intersect = false;

        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    grid: { color: '#3A3A3C', drawBorder: false },
                    ticks: { maxTicksLimit: 12, font: { size: 13 } }
                },
                y: {
                    grid: { color: '#3A3A3C', drawBorder: false },
                    ticks: { font: { size: 13 } }
                }
            },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        boxWidth: 8,
                        boxHeight: 8,
                        usePointStyle: true,
                        font: { size: 12, weight: 'normal' }
                    }
                }
            },
            elements: { point: { radius: 0 } } // 預設取消打點
        };

        // 記錄圖表的實例供後續更新
        let charts = {};

        function renderCharts(data) {
            // 解析資料陣列
            // 如果資料量太大，可以在這裡做簡單均值採樣，但 1440 筆 Chart.js 畫起來非常順
            const labels = data.map(d => {
                const date = new Date(d.created_at);
                return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            });

            const temps = data.map(d => d.temp);
            const dewpts = data.map(d => d.dewpt);
            const humidities = data.map(d => d.humidity);
            const windSpeeds = data.map(d => (d.wind_speed / 3.6).toFixed(1)); // 轉 m/s
            const windGusts = data.map(d => (d.wind_gust / 3.6).toFixed(1));   // 轉 m/s
            const windDirs = data.map(d => (d.wind_dir + 180) % 360);          // 校正方向
            const precipTotals = data.map(d => d.precip_total);
            const precipRates = data.map(d => d.precip_rate);
            const pressures = data.map(d => d.pressure);

            // 計算極值並更新上方 Summary 面板
            const maxTemp = Math.max(...temps);
            const minTemp = Math.min(...temps);
            const maxWindSpeed = Math.max(...windSpeeds);
            const maxWindGust = Math.max(...windGusts);
            const maxPrecipRate = Math.max(...precipRates);

            // 從資料中提取第一筆資料的日期來顯示
            const dataDate = data.length > 0 ? new Date(data[0].created_at) : new Date();
            const dateStr = `${dataDate.getMonth() + 1}/${dataDate.getDate()}`; // 格式 MM/DD

            document.getElementById('history-summary').innerHTML = `
                <div class="summary-item" style="border-right: 1px solid var(--border-color); padding-right: 15px; margin-right: 5px; display: flex; flex-direction: column; justify-content: center;">
                    <div class="summary-label" style="color: #F4F4F5;">日期</div>
                    <div class="summary-val" style="font-size: 26px; font-weight: 700; color: #FFF;">${dateStr}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">最高溫</div>
                    <div class="summary-val">${maxTemp.toFixed(1)} <span class="summary-unit">°C</span></div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">最低溫</div>
                    <div class="summary-val">${minTemp.toFixed(1)} <span class="summary-unit">°C</span></div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">最大風速</div>
                    <div class="summary-val">${maxWindSpeed.toFixed(1)} <span class="summary-unit">m/s</span></div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">最大陣風</div>
                    <div class="summary-val">${maxWindGust.toFixed(1)} <span class="summary-unit">m/s</span></div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">最大雨強</div>
                    <div class="summary-val">${maxPrecipRate.toFixed(1)} <span class="summary-unit">mm/hr</span></div>
                </div>
            `;

            // 1. 溫溼度 (Temperature & Dew Point)
            const ctxTemp = document.getElementById('chart-temp-dewpt').getContext('2d');
            if (charts.temp) charts.temp.destroy();
            charts.temp = new Chart(ctxTemp, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: '溫度 (°C)', data: temps, borderColor: '#EF4444', backgroundColor: 'rgba(239, 68, 68, 0.1)', borderWidth: 2, tension: 0.3 },
                        { label: '露點 (°C)', data: dewpts, borderColor: '#22C55E', backgroundColor: 'rgba(34, 197, 94, 0.1)', borderWidth: 2, tension: 0.3 }
                    ]
                },
                options: commonOptions
            });

            // x. 濕度 (Humidity)
            const ctxHumidity = document.getElementById('chart-humidity').getContext('2d');
            if (charts.humidity) charts.humidity.destroy();
            charts.humidity = new Chart(ctxHumidity, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: '相對濕度 (%)', data: humidities, borderColor: '#0EA5E9', backgroundColor: 'rgba(14, 165, 233, 0.1)', borderWidth: 2, fill: true, tension: 0.3 }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        x: commonOptions.scales.x,
                        y: {
                            ...commonOptions.scales.y,
                            min: 0,
                            max: 100
                        }
                    }
                }
            });

            // 2. 風速與陣風
            const ctxWindSpeed = document.getElementById('chart-wind-speed').getContext('2d');
            if (charts.windSpeed) charts.windSpeed.destroy();
            charts.windSpeed = new Chart(ctxWindSpeed, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: '平均風速 (m/s)', data: windSpeeds, borderColor: '#3B82F6', fill: true, backgroundColor: 'rgba(59, 130, 246, 0.2)', borderWidth: 2, tension: 0.3 },
                        { label: '陣風 (m/s)', data: windGusts, borderColor: '#F97316', backgroundColor: '#F97316', borderWidth: 0, elements: { point: { radius: 2, pointStyle: 'circle' } }, showLine: false } // 陣風用灑點表現
                    ] // 這裡刻意讓陣風顯示為點，與參考圖類似
                },
                options: commonOptions
            });

            // 3. 風向散佈圖
            const ctxWindDir = document.getElementById('chart-wind-dir').getContext('2d');
            if (charts.windDir) charts.windDir.destroy();

            // 深層複製共用設定，因為 y 軸要特製成羅盤代號
            const windDirOptions = JSON.parse(JSON.stringify(commonOptions));
            windDirOptions.scales.y.min = 0;
            windDirOptions.scales.y.max = 360;
            windDirOptions.scales.y.ticks = {
                stepSize: 90,
                callback: function (value) {
                    if (value === 0 || value === 360) return 'N';
                    if (value === 90) return 'E';
                    if (value === 180) return 'S';
                    if (value === 270) return 'W';
                    return value;
                }
            };
            windDirOptions.elements.point.radius = 2; // 開啟打點

            charts.windDir = new Chart(ctxWindDir, {
                type: 'scatter', // 用散佈圖畫風向
                data: {
                    datasets: [{
                        label: '風向',
                        data: windDirs.map((dir, i) => ({ x: i, y: dir })),
                        backgroundColor: '#3B82F6',
                        borderColor: '#3B82F6'
                    }]
                },
                options: {
                    ...windDirOptions,
                    scales: {
                        x: {
                            type: 'category',
                            labels: labels,
                            grid: { color: '#3A3A3C', drawBorder: false },
                            ticks: { maxTicksLimit: 12 }
                        },
                        y: windDirOptions.scales.y
                    },
                    plugins: { legend: { position: 'bottom' } }
                }
            });

            // 4. 降雨量
            const ctxPrecip = document.getElementById('chart-precip').getContext('2d');
            if (charts.precip) charts.precip.destroy();
            charts.precip = new Chart(ctxPrecip, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: '累積日降雨 (mm)', data: precipTotals, borderColor: '#06B6D4', backgroundColor: 'rgba(6, 182, 212, 0.1)', borderWidth: 2, fill: true, tension: 0 },
                        { label: '即時雨強 (mm/hr)', data: precipRates, borderColor: '#84CC16', backgroundColor: '#84CC16', type: 'bar' }
                    ]
                },
                options: commonOptions
            });

            // 5. 氣壓
            const ctxPressure = document.getElementById('chart-pressure').getContext('2d');
            if (charts.pressure) charts.pressure.destroy();
            charts.pressure = new Chart(ctxPressure, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: '氣壓 (hPa)', data: pressures, borderColor: '#E5E7EB', backgroundColor: 'rgba(229, 231, 235, 0.05)', borderWidth: 2, tension: 0.1 }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        x: commonOptions.scales.x,
                        y: {
                            ...commonOptions.scales.y,
                            min: Math.floor(Math.min(...pressures)) - 2, // 動態取得最小值 -2 讓線條在中間稍微波動
                            max: Math.ceil(Math.max(...pressures)) + 2
                        }
                    }
                }
            });
        }

    </script>
</body>

</html>